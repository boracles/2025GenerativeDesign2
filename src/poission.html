<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Poisson Disk Sampling — three.js</title>
    <style>
      :root {
        color-scheme: dark;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        background: #111;
        overflow: hidden;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial;
      }
      #hud {
        position: fixed;
        right: 12px;
        top: 12px;
        display: flex;
        gap: 8px;
        z-index: 10;
      }
      .btn {
        border: 1px solid #333;
        background: #1b1b1b;
        color: #ddd;
        padding: 8px 10px;
        border-radius: 10px;
        cursor: pointer;
      }
      .btn:hover {
        background: #262626;
      }
      #info {
        position: fixed;
        left: 12px;
        bottom: 12px;
        font-size: 12px;
        opacity: 0.8;
        color: #bbb;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
        }
      }
    </script>
  </head>
  <body>
    <div id="hud">
      <button id="btnExport" class="btn">Export PNG</button>
      <button id="btnRegen" class="btn">Regenerate</button>
    </div>
    <div id="info"></div>
    <script type="module">
      import * as THREE from "three";
      import GUI from "lil-gui";

      // -----------------------
      // Config & state
      // -----------------------
      const params = {
        width: 1024, // 출력 캔버스(또는 이미지) 크기
        height: 1024,
        radius: 14, // 최소 거리(px)
        k: 30, // 각 활성점에서의 후보 수 (Bridson 권장 30)
        seed: 12345, // 재현 가능한 난수 시드
        pointSize: 4.0, // 점 표시 크기(PX)
        margin: 8, // 가장자리 여백
        bg: "#111111",
        fg: "#d7e7ff",
        autoFit: true, // 창 크기에 맞춰 화면 스케일
      };

      // -----------------------
      // Renderer & Scene
      // -----------------------
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        preserveDrawingBuffer: true,
      });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(params.width, params.height);
      renderer.setClearColor(params.bg);
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();

      // 정사각 패널에 정사영 카메라: "이미지"처럼 2D 렌더
      const camera = new THREE.OrthographicCamera(
        0,
        params.width,
        0,
        params.height,
        -1,
        1
      );
      camera.position.z = 1;

      // 점 그리기용 Points
      let pointsMesh = null;
      const group = new THREE.Group();
      scene.add(group);

      // 창 크기 대응(뷰 스케일)
      function resizeView() {
        if (!params.autoFit) return;
        const margin = 0;
        const w = window.innerWidth - margin * 2;
        const h = window.innerHeight - margin * 2;
        const sx = w / params.width;
        const sy = h / params.height;
        const s = Math.min(sx, sy);
        renderer.domElement.style.width = params.width * s + "px";
        renderer.domElement.style.height = params.height * s + "px";
        renderer.domElement.style.display = "block";
        renderer.domElement.style.margin = "0 auto";
      }
      window.addEventListener("resize", resizeView);

      // -----------------------
      // Seeded RNG (Mulberry32)
      // -----------------------
      function mulberry32(a) {
        return function () {
          let t = (a += 0x6d2b79f5);
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      // -----------------------
      // Poisson Disk Sampling (Bridson 2007)
      //  - 공간: [margin, width-margin] x [margin, height-margin]
      //  - 최소 거리: r
      //  - 각 활성점에서 k개의 후보를 시도
      //  - 그리드 가속으로 O(n)
      // -----------------------
      function poissonDisk2D(width, height, r, k, margin, rng) {
        const minX = margin,
          maxX = width - margin;
        const minY = margin,
          maxY = height - margin;
        const w = maxX - minX;
        const h = maxY - minY;

        if (w <= 0 || h <= 0) return [];

        const cellSize = r / Math.SQRT2;
        const gridWidth = Math.ceil(w / cellSize);
        const gridHeight = Math.ceil(h / cellSize);
        const grid = new Array(gridWidth * gridHeight).fill(-1);

        const points = [];
        const active = [];

        function gridIndex(x, y) {
          const gx = Math.floor((x - minX) / cellSize);
          const gy = Math.floor((y - minY) / cellSize);
          return gy * gridWidth + gx;
        }

        function inBounds(x, y) {
          return x >= minX && x < maxX && y >= minY && y < maxY;
        }

        function isFarEnough(x, y) {
          const gx = Math.floor((x - minX) / cellSize);
          const gy = Math.floor((y - minY) / cellSize);
          const r2 = r * r;

          for (
            let yy = Math.max(gy - 2, 0);
            yy <= Math.min(gy + 2, gridHeight - 1);
            yy++
          ) {
            for (
              let xx = Math.max(gx - 2, 0);
              xx <= Math.min(gx + 2, gridWidth - 1);
              xx++
            ) {
              const gi = yy * gridWidth + xx;
              const pi = grid[gi];
              if (pi !== -1) {
                const px = points[pi].x;
                const py = points[pi].y;
                const dx = px - x,
                  dy = py - y;
                if (dx * dx + dy * dy < r2) return false;
              }
            }
          }
          return true;
        }

        // 초기 시드 포인트 하나
        const x0 = minX + rng() * w;
        const y0 = minY + rng() * h;
        points.push({ x: x0, y: y0 });
        grid[gridIndex(x0, y0)] = 0;
        active.push(0);

        while (active.length > 0) {
          // 활성 목록에서 무작위 선택
          const idx = Math.floor(rng() * active.length);
          const pIndex = active[idx];
          const px = points[pIndex].x,
            py = points[pIndex].y;

          let found = false;
          for (let i = 0; i < k; i++) {
            // r~2r 사이 임의의 고리에서 샘플
            const ang = 2 * Math.PI * rng();
            const rad = r * (1 + rng()); // [r, 2r)
            const nx = px + Math.cos(ang) * rad;
            const ny = py + Math.sin(ang) * rad;

            if (inBounds(nx, ny) && isFarEnough(nx, ny)) {
              const newIndex = points.length;
              points.push({ x: nx, y: ny });
              grid[gridIndex(nx, ny)] = newIndex;
              active.push(newIndex);
              found = true;
            }
          }
          if (!found) {
            // 더 이상 주변에서 유효 후보가 없으면 비활성화
            active.splice(idx, 1);
          }
        }
        return points;
      }

      // -----------------------
      // Build / Update point cloud
      // -----------------------
      function rebuild() {
        // 난수 고정
        const rng = mulberry32(params.seed >>> 0);

        // 샘플 생성
        const pts = poissonDisk2D(
          params.width,
          params.height,
          params.radius,
          params.k,
          params.margin,
          rng
        );

        // 기존 mesh 제거
        if (pointsMesh) {
          group.remove(pointsMesh);
          pointsMesh.geometry.dispose();
          pointsMesh.material.dispose();
          pointsMesh = null;
        }

        // 포지션 버퍼 만들기 (좌표계를 ortho에 맞춰 y-up을 화면 위로)
        const positions = new Float32Array(pts.length * 3);
        for (let i = 0; i < pts.length; i++) {
          positions[3 * i + 0] = pts[i].x;
          positions[3 * i + 1] = params.height - pts[i].y; // 화면 좌하 (0,0) 맞추기용 뒤집기
          positions[3 * i + 2] = 0;
        }

        const geom = new THREE.BufferGeometry();
        geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));

        const mat = new THREE.PointsMaterial({
          size: params.pointSize,
          sizeAttenuation: false, // px 고정
          color: new THREE.Color(params.fg),
        });

        pointsMesh = new THREE.Points(geom, mat);
        group.add(pointsMesh);

        // 배경색 업데이트
        renderer.setClearColor(new THREE.Color(params.bg));

        // 정보 표시
        document.getElementById(
          "info"
        ).textContent = `points: ${pts.length} | r: ${params.radius}px, k: ${params.k}, seed: ${params.seed}`;
      }

      // -----------------------
      // GUI
      // -----------------------
      const gui = new GUI({ title: "Poisson Disk Sampling" });
      gui
        .add(params, "radius", 4, 60, 1)
        .name("min distance (px)")
        .onChange(rebuild);
      gui.add(params, "k", 5, 60, 1).name("candidates (k)").onChange(rebuild);
      gui
        .add(params, "seed", 1, 1 << 30, 1)
        .name("seed")
        .onFinishChange(rebuild);
      gui.addColor(params, "fg").name("point color").onChange(rebuild);
      gui.addColor(params, "bg").name("background").onChange(rebuild);
      gui
        .add(params, "pointSize", 1, 12, 1)
        .name("point size(px)")
        .onChange(rebuild);
      gui
        .add(params, "margin", 0, 40, 1)
        .name("edge margin(px)")
        .onChange(rebuild);
      gui
        .add(params, "autoFit")
        .name("auto fit to window")
        .onChange(resizeView);

      // -----------------------
      // Export & Regen buttons
      // -----------------------
      document.getElementById("btnExport").addEventListener("click", () => {
        // 원본 해상도로 빠르게 다시 그린 뒤 저장
        renderer.setSize(params.width, params.height);
        renderOnce();
        const url = renderer.domElement.toDataURL("image/png");
        const a = document.createElement("a");
        a.href = url;
        a.download = `poisson_disk_r${params.radius}_k${params.k}_seed${params.seed}.png`;
        a.click();
        resizeView(); // 보기 크기 되돌림
      });

      document.getElementById("btnRegen").addEventListener("click", () => {
        params.seed = (params.seed + 1) >>> 0;
        gui.updateDisplay(); // 패널 값 갱신
        rebuild();
      });

      // -----------------------
      // Render
      // -----------------------
      function renderOnce() {
        renderer.clear();
        renderer.render(scene, camera);
      }
      function loop() {
        renderOnce();
        requestAnimationFrame(loop);
      }

      // Init
      rebuild();
      resizeView();
      loop();
    </script>
  </body>
</html>
